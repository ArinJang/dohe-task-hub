<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="Taskhub">

    <sql id="sessionUserId">
        AND T.USER_ID = #{user_id}
    </sql>

    <select id="callInsertTaskAndDoDates" parameterType="map">
        CALL InsertTaskAndDoDates(
        #{task_content},
        #{do_dates},
        #{task_order},
        #{user_id}
        )
    </select>

    <delete id="deleteDoDatesByTaskId" parameterType="string">
        DELETE FROM DODATES WHERE TASK_ID = #{taskId}
    </delete>

    <!-- 1. TASK_ORDER 값을 계산 -->
    <select id="getMaxTaskOrder" parameterType="map" resultType="int">
        SELECT COALESCE(MAX(D.TASK_ORDER) + 1, 0)
        FROM DODATES D JOIN TASK T
             ON T.TASK_ID = D.TASK_ID
        WHERE 1=1
        <include refid="sessionUserId" />
        AND D.DO_DATE = #{do_date}
    </select>

    <!-- 2. INSERT 실행 -->
    <insert id="insertDoDate">
        INSERT INTO DODATES (TASK_ID, DO_DATE, TASK_ORDER)
        VALUES (#{taskId}
              , #{do_date}
              , #{taskOrder});
    </insert>

    <select id="findAll" resultType="taskhubdto">
        SELECT
            T.TASK_ID,
            T.TASK_CONTENT,
            T.USER_ID,
            CONCAT('(', 'work_name', ')') AS WORK_NAME,
            DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
            CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
            CASE
            WHEN D.DO_DATE = '9999-12-31' THEN NULL
            ELSE D.DO_DATE
            END AS DO_DATE,
            D.TASK_ORDER,
            T.TASK_STATUS
        FROM TASK T RIGHT JOIN DODATES D
             ON T.task_id = D.task_id
        WHERE 1=1
        <include refid="sessionUserId" />
        AND D.do_date = '9999-12-31'
        AND T.TASK_STATUS NOT IN (4, 5, 6)
        ORDER BY
        D.TASK_ORDER;
    </select>

    <select id="findByDoDates" parameterType="taskhubdto" resultType="taskhubdto">
        WITH RECURSIVE numbers AS (
        SELECT 1 AS num
        UNION ALL
        SELECT num + 1
        FROM numbers
        WHERE num <![CDATA[<]]> 100
        -- Adjust based on your max expected number of dates
        ),
        split_dates AS (
        SELECT
        T.TASK_ID,
        T.TASK_CONTENT,
        CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
        T.TASK_STATUS,
        CONCAT('(', 'work_name', ')') AS WORK_NAME,
        D.DO_DATE,
        D.TASK_ORDER
        FROM TASK T JOIN DODATES D
             ON T.TASK_ID = D.TASK_ID
        WHERE 1=1
        <include refid="sessionUserId" />
        AND D.DO_DATE BETWEEN #{mon} AND #{sun}
        ),
        filtered_dates AS (
        SELECT
        TASK_ID,
        TASK_CONTENT,
        DUE_DATE,
        TASK_STATUS,
        WORK_NAME,
        DO_DATE,
        TASK_ORDER
        FROM
        split_dates
        )
        SELECT
        TASK_ID,
        TASK_CONTENT,
        DUE_DATE,
        TASK_STATUS,
        WORK_NAME,
        UPPER(DATE_FORMAT(DO_DATE, '%a')) AS day_of_week
        FROM
        filtered_dates
        ORDER BY
        TASK_ORDER, -- Order by TASK_ORDER in descending order
        TASK_STATUS,
        TASK_ID DESC;

    </select>

    <select id="findById" parameterType="String" resultType="taskhubdto">
        SELECT
        T.TASK_ID,
        T.TASK_CONTENT,
        T.TASK_STATUS,
        T.TASK_ORDER,
        T.TASK_MEMO,
        T.ASSIGNEE_ID,
        T.CATEGORY_ID AS CATEGORY_NAME,
        T.WORK_ID AS WORK_NAME,
        T.USER_ID,
        DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
        DATE_FORMAT(T.DUE_DATE, '%Y-%m-%d') AS DUE_DATE,
        UPPER(DATE_FORMAT(T.DUE_DATE, '%a')) AS day_of_week,
        IFNULL(
        (SELECT GROUP_CONCAT(
        CASE
        <!--WHEN D.DO_DATE = '9999-12-31' THEN NULL-->
        WHEN D.DO_DATE like '9999%' THEN NULL
        ELSE DATE_FORMAT(D.DO_DATE, '%Y-%m-%d')
        END
        ORDER BY D.DO_DATE ASC
        SEPARATOR ','
        )
        FROM DODATES D
        WHERE D.TASK_ID = T.TASK_ID),
        ''
        ) AS DO_DATES
        FROM
        TASK T
        WHERE
        T.TASK_ID = #{taskId};
    </select>

    <select id="findNewId" parameterType="taskhubdto" resultType="int">
        SELECT MAX(T.TASK_ID) FROM TASK T
        WHERE 1=1
        <include refid="sessionUserId" />
        AND T.DUE_DATE IS NULL
    </select>

    <select id="findByStatus" parameterType="taskhubdto" resultType="taskhubdto">
        SELECT T.TASK_ID, T.TASK_CONTENT, T.USER_ID,
        CONCAT('(', 'work_name',')') AS WORK_NAME,
        DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
        CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
        D.DO_DATE,
        T.TASK_STATUS
        FROM TASK T RIGHT JOIN DODATES D
             ON T.task_id = D.task_id
        WHERE 1=1
        <include refid="sessionUserId" />
        AND (
        (#{task_status} = 2 AND T.TASK_STATUS = #{task_status})
        OR (#{task_status} != 2 AND T.TASK_STATUS = #{task_status} AND D.DO_DATE LIKE '9999-01-%')
        )
        ORDER BY
        D.TASK_ORDER;
    </select>

    <update id="updateTask" parameterType="taskhubdto">
        UPDATE TASK
            SET
            TASK_CONTENT = #{task_content},
            DUE_DATE = CASE
                        WHEN #{due_date} IS NULL OR #{due_date} = '' THEN NULL
                        ELSE #{due_date}
                        END,
            TASK_STATUS = #{task_status},
            TASK_MEMO = #{task_memo}
        WHERE TASK_ID = #{task_id}
    </update>

    <update id="updateStatus" parameterType="map">
        UPDATE TASK
        SET
        TASK_STATUS = #{task_status}
        WHERE TASK_ID = #{task_id}
    </update>

    <select id="getOldDoDateAndOrder" parameterType="String" resultType="map">
        SELECT DO_DATE AS old_do_date, TASK_ORDER AS old_order_idx
        FROM DODATES
        WHERE TASK_ID = #{task_id}
        LIMIT 1;
    </select>

    <select id="getMaxIdxOfNewDate" parameterType="map" resultType="String">
        SELECT COALESCE(MAX(D.TASK_ORDER) + 1, 0) AS new_idx
        FROM TASK T JOIN DODATES D
             ON T.TASK_ID = D.TASK_ID
        WHERE 1=1
        <include refid="sessionUserId" />
        AND D.DO_DATE = #{newDoDate};
    </select>

    <update id="updateOrderAndDoDateInDifferentDate1" parameterType="taskhubdto">
        <!-- [case1: 이동하는 날짜그룹 상이] 1. taskid의 원래 do_date에서 현 task_id가 빠진 채로 다시 인덱싱하여 TASK_ORDER 부여 -->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET D.TASK_ORDER = D.TASK_ORDER - 1
        WHERE 1=1
        <include refid="sessionUserId" />
        AND D.DO_DATE = #{old_do_date}
        AND D.TASK_ORDER <![CDATA[>]]> #{old_order_idx};
    </update>

    <update id="updateOrderAndDoDateInDifferentDate2" parameterType="taskhubdto">
        <!-- [case1: 이동하는 날짜그룹 상이] 2. taskid가 이동하는 do_date에서 현 task_id가 이동하려는 인덱스 이하의 데이터들의 task_order 1 증가 -->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET D.TASK_ORDER = D.TASK_ORDER + 1
        WHERE 1=1
        <include refid="sessionUserId" />
        AND D.DO_DATE = #{new_do_date}
        AND D.TASK_ORDER >= #{new_order_idx};
    </update>

    <update id="updateOrderAndDoDateOfTask" parameterType="taskhubdto">
        <!-- [case1 & case2] 현재 taskid의 do_date와 task_order 변경-->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET
        D.DO_DATE = #{new_do_date},
        D.TASK_ORDER = #{new_order_idx}
        WHERE 1=1
        <include refid="sessionUserId" />
        AND D.TASK_ID = #{task_id}
        AND D.DO_DATE = #{old_do_date};
        <!--INSERT INTO DODATES (DO_DATE, TASK_ID, TASK_ORDER) VALUES
        (#{new_do_date},#{task_id},#{task_order_idx})-->
    </update>

    <update id="updateOrderAndDoDateInSameDateDown" parameterType="taskhubdto">
        <!-- [case2: 이동하는 날짜그룹 동일] 1. Moving Downwards -->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET D.TASK_ORDER = D.TASK_ORDER - 1
        WHERE 1=1
        <include refid="sessionUserId" />
        AND D.DO_DATE = #{new_do_date}
        AND D.TASK_ORDER > #{old_order_idx}
        AND D.TASK_ORDER <![CDATA[<=]]> #{new_order_idx};
    </update>

    <update id="updateOrderAndDoDateInSameDateUp" parameterType="taskhubdto">
        <!-- [case2: 이동하는 날짜그룹 동일] 2. Moving Upwards -->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET D.TASK_ORDER = D.TASK_ORDER + 1
        WHERE 1=1
        <include refid="sessionUserId" />
        AND D.DO_DATE = #{new_do_date}
        AND D.TASK_ORDER >= #{new_order_idx}
        AND D.TASK_ORDER <![CDATA[<]]> #{old_order_idx};
    </update>

    <update id="assignOtherOrder" parameterType="String">
        -- 1. Temporarily set TASK_ORDER for the specified TASK_ID to a placeholder value
        UPDATE DODATES
        SET TASK_ORDER = 999999
        WHERE TASK_ID = #{task_id};
    </update>

    <update id="rearrangeOrder" parameterType="map">
        <!--WITH OrderedTasks AS (
        SELECT
        D.DO_DATE,
        D.TASK_ID,
        CASE
        WHEN @current_do_date = D.DO_DATE THEN @row_number := @row_number + 1
        ELSE @row_number := 0
        END AS new_task_order,
        @current_do_date := D.DO_DATE
        FROM
        (SELECT @row_number := -1, @current_do_date := NULL) AS vars,  &#45;&#45; Initialize variables
        DODATES D
        WHERE
        D.DO_DATE IN (
        SELECT DO_DATE
        FROM DODATES
        WHERE TASK_ID = #{task_id}
        )
        AND D.TASK_ID != #{task_id}  &#45;&#45; Exclude the TASK_ID being processed
        ORDER BY
        D.DO_DATE, D.TASK_ORDER
        )
        UPDATE DODATES D
        JOIN OrderedTasks OT
        ON D.DO_DATE = OT.DO_DATE AND D.TASK_ID = OT.TASK_ID
        SET D.TASK_ORDER = OT.new_task_order;-->
        -- Step 1: Define the CTE to calculate the new task order
        WITH OrderedTasks AS (
        SELECT
        D.DO_DATE,
        D.TASK_ID,
        CASE
        WHEN @current_do_date = D.DO_DATE THEN @row_number := @row_number + 1
        ELSE @row_number := 0
        END AS new_task_order,
        @current_do_date := D.DO_DATE
        FROM
        (SELECT @row_number := -1, @current_do_date := NULL) AS vars,  -- Initialize variables
        DODATES D
        JOIN TASK T ON D.TASK_ID = T.TASK_ID  -- Join with TASK to filter by user_id
        WHERE 1=1
        <include refid="sessionUserId" />
        AND D.DO_DATE IN (
        SELECT DO_DATE
        FROM DODATES
        WHERE TASK_ID = #{task_id}
        )
        AND D.TASK_ID != #{task_id}  -- Exclude the TASK_ID being processed
        ORDER BY
        D.DO_DATE, D.TASK_ORDER
        )

        -- Step 2: Update the DODATES table with the new task order values
        UPDATE DODATES D JOIN OrderedTasks OT
               ON D.DO_DATE = OT.DO_DATE
        AND D.TASK_ID = OT.TASK_ID
        JOIN TASK T ON D.TASK_ID = T.TASK_ID  -- Join with TASK to filter by user_id
        SET D.TASK_ORDER = OT.new_task_order
        WHERE 1=1
        <include refid="sessionUserId" />;  -- Ensure only rows for the specified user_id are updated

    </update>

    <delete id="deleteTask" parameterType="String">
        DELETE FROM TASK WHERE TASK_ID = #{task_id}
    </delete>

    <select id="getCategories" resultType="taskhubdto">
        SELECT T.CATEGORY_ID, T.CATEGORY_NAME, T.CATEGORY_ORDER, T.USER_ID
        FROM CATEGORY T
        WHERE 1=1
        <include refid="sessionUserId" />
        ORDER BY T.CATEGORY_ORDER;
    </select>

</mapper>

