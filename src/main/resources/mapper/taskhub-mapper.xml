<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="Taskhub">

    <sql id="sessionUserId">
        AND T.USER_ID = #{user_id}
    </sql>

    <select id="callInsertTaskAndDoDates" parameterType="map">
        CALL InsertTaskAndDoDates(
        #{task_content},
        #{do_dates},
        <!--#{task_order},-->
        #{user_id},
        #{parent_task_id}
        )
    </select>

    <insert id="insertWork">
        INSERT INTO WORK (WORK_NAME, USER_ID)
        VALUES (#{work_name}
              , #{user_id});
    </insert>

    <delete id="deleteDoDatesByTaskId" parameterType="string">
        DELETE FROM DODATES WHERE TASK_ID = #{taskId}
    </delete>

    <delete id="deleteDoDatesByTaskId2" parameterType="map">
        DELETE FROM DODATES WHERE TASK_ID = #{task_id} AND DO_DATE = #{do_date}
    </delete>

    <!-- 1. TASK_ORDER 값을 계산 -->
    <select id="getMaxTaskOrder" parameterType="map" resultType="int">
        SELECT COALESCE(MAX(D.TASK_ORDER) + 1, 0)
        FROM DODATES D JOIN TASK T
             ON T.TASK_ID = D.TASK_ID
        WHERE 1=1
        <include refid="sessionUserId" />
        AND D.DO_DATE = #{do_date}
    </select>

    <!-- 2. INSERT 실행 -->
    <insert id="insertDoDate">
        INSERT INTO DODATES (TASK_ID, DO_DATE, TASK_ORDER
                            <if test="task_done != null">
                                , TASK_DONE
                            </if>
                            )
        VALUES (#{task_id}, #{do_date}, #{task_order}
                <if test="task_done != null">
                    , #{task_done}
                </if>
                );
    </insert>

    <select id="findAll" resultType="taskhubdto">
        SELECT
            T.TASK_ID,
            T.TASK_CONTENT,
            T.USER_ID,
            COALESCE(CONCAT('(', W.WORK_NAME, ')'), '') AS WORK_NAME,
            DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
            CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
            <!--CASE
            WHEN D.DO_DATE = '9999-12-31' THEN NULL
            ELSE D.DO_DATE
            END AS DO_DATE,-->
            D.DO_DATE,
            D.TASK_ORDER,
            D.TASK_DONE,
            T.TASK_STATUS,
            CASE WHEN T.PARENT_TASK IS NOT NULL THEN
                 (SELECT P.TASK_CONTENT FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
                 ELSE '0'
                 END AS PARENT_TASK_CONTENT,
            CASE WHEN T.DUE_DATE <![CDATA[<=]]> CURDATE() AND T.TASK_STATUS NOT IN (2, 3) THEN 1
                 ELSE 0
                 END AS IS_OVERDUE
        FROM TASK T RIGHT JOIN DODATES D
             ON T.task_id = D.task_id
             LEFT JOIN WORK W ON T.WORK_ID = W.WORK_ID
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.do_date = '9999-12-31'
        AND T.TASK_STATUS NOT IN (4, 5, 6)
        ORDER BY
        D.TASK_ORDER;
    </select>

    <select id="findTaskContent" parameterType="Long" resultType="taskhubdto">
        SELECT
        T.TASK_CONTENT,
        T.TASK_STATUS
        FROM TASK T
        WHERE 1=1
        AND T.TASK_ID = #{task_id}
        ORDER BY T.TASK_ID;
    </select>

    <select id="findByDoDates" parameterType="taskhubdto" resultType="taskhubdto">
        <!--WITH RECURSIVE numbers AS (SELECT
                                    1 AS num
                                    UNION ALL
                                    SELECT
                                    num + 1
                                    FROM numbers
                                    WHERE num <![CDATA[<]]> 100 ),
        split_dates AS (SELECT
                        T.TASK_ID,
                        T.TASK_CONTENT,
                        CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
                        T.DUE_DATE AS ORI_DUE_DATE,
                        T.TASK_STATUS,
                        COALESCE(CONCAT('(', W.WORK_NAME, ')'), '') AS WORK_NAME,
                        D.DO_DATE,
                        D.TASK_DONE,
                        D.TASK_ORDER
                        FROM
                        TASK T
                        JOIN DODATES D
                        ON
                        T.TASK_ID = D.TASK_ID
                        LEFT JOIN WORK W ON
                        T.WORK_ID = W.WORK_ID
                        WHERE 1 = 1
                        <include refid = "sessionUserId" />
                        AND D.DO_DATE BETWEEN #{mon} AND #{sun} ),
        filtered_dates AS (SELECT
                                TASK_ID,
                                TASK_CONTENT,
                                DUE_DATE,
                                TASK_DONE,
                                TASK_STATUS,
                                WORK_NAME,
                                DO_DATE,
                                TASK_ORDER,
                                ORI_DUE_DATE
                            FROM split_dates )
        SELECT
            TASK_ID,
            TASK_CONTENT,
            DUE_DATE,
            TASK_DONE,
            TASK_STATUS,
            WORK_NAME,
            UPPER(DATE_FORMAT(DO_DATE, '%a')) AS day_of_week,
            CASE WHEN ORI_DUE_DATE <![CDATA[<=]]> CURDATE() AND TASK_STATUS NOT IN (2, 3) THEN 1
                 ELSE 0
                 END AS IS_OVERDUE
        FROM filtered_dates
        ORDER BY
        TASK_ORDER,
        TASK_STATUS,
        TASK_ID DESC;-->
        SELECT
        T.TASK_ID,
        T.TASK_CONTENT,
        CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
        D.TASK_DONE,
        T.TASK_STATUS,
        CASE WHEN T.PARENT_TASK IS NOT NULL THEN
        (SELECT P.TASK_CONTENT FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
        ELSE '0'
        END AS PARENT_TASK_CONTENT,
        COALESCE(CONCAT('(', (SELECT WORK_NAME FROM WORK WHERE WORK_ID = T.WORK_ID), ')'), '') AS WORK_NAME,
        UPPER(DATE_FORMAT(D.DO_DATE, '%a')) AS day_of_week,
        CASE    WHEN T.DUE_DATE <![CDATA[<=]]> CURDATE()
                AND T.TASK_STATUS NOT IN (2, 3) THEN 1
                ELSE 0
                END                         AS IS_OVERDUE,
        D.DO_DATE
        FROM TASK T RIGHT JOIN DODATES D
             ON T.task_id = D.task_id
        WHERE 1 = 1
        <include refid = "sessionUserId" />
        AND D.do_date BETWEEN #{mon} AND #{sun}
        ORDER BY D.TASK_ORDER,
                 T.TASK_STATUS,
                 D.TASK_ID DESC
    </select>

    <select id="findByWork" parameterType="Long" resultType="taskhubdto">
        SELECT
                T.TASK_ID,
                T.TASK_CONTENT,
                T.USER_ID,
                W.WORK_ID,
                W.WORK_NAME,
                DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
                CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
                T.TASK_STATUS,
                CASE WHEN T.DUE_DATE <![CDATA[<=]]> CURDATE() AND T.TASK_STATUS NOT IN (2, 3) THEN 1
                     ELSE 0
                     END AS IS_OVERDUE
          FROM TASK T RIGHT JOIN WORK W ON T.WORK_ID = W.WORK_ID
         WHERE 1=1
           <!--<include refid="sessionUserId"/>-->
           AND W.USER_ID = #{user_id}
           <!--AND T.WORK_ID IS NOT NULL-->
         ORDER BY W.WORK_ID, T.TASK_ORDER;
    </select>

    <select id="findWorks" parameterType="Long" resultType="taskhubdto">
        SELECT
                W.WORK_ID,
                W.WORK_NAME AS WORK_NAME
        FROM WORK W
        WHERE 1=1
        AND W.USER_ID = #{user_id}
        ORDER BY W.WORK_ID;
    </select>

    <select id="findById" parameterType="map" resultType="taskhubdto">
        SELECT
        T.TASK_ID,
        T.TASK_CONTENT,
        T.TASK_STATUS,
        T.TASK_ORDER,
        <!--T.TASK_MEMO,-->
        CASE WHEN T.PARENT_TASK IS NOT NULL THEN
             (SELECT P.TASK_MEMO FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
             ELSE T.TASK_MEMO
             END AS TASK_MEMO,
        T.ASSIGNEE_ID,
        T.CATEGORY_ID AS CATEGORY_NAME,
        T.WORK_ID AS WORK_ID,
        (SELECT W.WORK_NAME FROM WORK W WHERE W.WORK_ID = T.WORK_ID) AS WORK_NAME,
        T.USER_ID,
        DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
        DATE_FORMAT(T.DUE_DATE, '%Y-%m-%d') AS DUE_DATE,
        UPPER(DATE_FORMAT(T.DUE_DATE, '%a')) AS day_of_week,
        IFNULL(
                (SELECT GROUP_CONCAT(
                                    CASE
                                    WHEN D.DO_DATE like '9999%' THEN NULL
                                    ELSE DATE_FORMAT(D.DO_DATE, '%Y-%m-%d')
                                    END
                                    ORDER BY D.DO_DATE ASC
                                    SEPARATOR ','
                                    )
                        FROM DODATES D
                        WHERE D.TASK_ID = T.TASK_ID),
                ''
                ) AS DO_DATES,
        IFNULL(
                (SELECT GROUP_CONCAT(TASK_ID ORDER BY TASK_ID ASC
                                     SEPARATOR ',')
                FROM TASK
                WHERE PARENT_TASK = #{task_id}),
                ''
                ) AS SUB_TASKS,
        IFNULL(PARENT_TASK, 0) AS PARENT_TASK_ID,
        CASE
            WHEN #{do_date} IS NOT NULL THEN
            (SELECT TASK_DONE
            FROM DODATES
            WHERE TASK_ID = #{task_id}
            AND DO_DATE = #{do_date})
            ELSE NULL
            END AS TASK_DONE,
        CASE
            WHEN #{do_date} IS NOT NULL AND #{do_date} NOT LIKE '9999%' THEN
            CONCAT(SUBSTRING(#{do_date}, 6, 2), '/', SUBSTRING(#{do_date}, 9, 2))  -- MM/DD 형식으로 변환
            ELSE NULL
            END AS DO_DATE,
        #{do_date} AS ORI_DO_DATE,
        '' AS UPPER_TASK
        FROM
        TASK T
        WHERE
        T.TASK_ID = #{task_id};
    </select>

    <select id="findLatestDoDateById" parameterType="Long" resultType="String">
        SELECT MAX(DO_DATE) AS DO_DATE
          FROM DODATES
         WHERE TASK_ID = #{task_id};
    </select>

    <select id="findNewId" parameterType="taskhubdto" resultType="int">
        SELECT MAX(T.TASK_ID) FROM TASK T
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND T.DUE_DATE IS NULL
    </select>

    <select id="findByStatus" parameterType="taskhubdto" resultType="taskhubdto">
        SELECT
        T.TASK_ID,
        T.TASK_CONTENT,
        T.USER_ID,
        COALESCE(CONCAT('(', W.WORK_NAME, ')'), '') AS WORK_NAME,
        DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
        CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
        D.DO_DATE,
        D.TASK_DONE,
        T.TASK_STATUS,
        CASE WHEN T.PARENT_TASK IS NOT NULL THEN
        (SELECT P.TASK_CONTENT FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
        ELSE '0'
        END AS PARENT_TASK_CONTENT,
        CASE WHEN T.DUE_DATE <![CDATA[<=]]> CURDATE() AND T.TASK_STATUS NOT IN (2, 3) THEN 1
             ELSE 0
             END AS IS_OVERDUE
        FROM TASK T     RIGHT JOIN DODATES D ON T.TASK_ID = D.TASK_ID
                        LEFT JOIN  WORK W    ON T.WORK_ID = W.WORK_ID
        WHERE
        1=1
        <include refid="sessionUserId"/>
        AND (
        (#{task_status} = 2 AND T.TASK_STATUS = #{task_status})
        OR (#{task_status} != 2 AND T.TASK_STATUS = #{task_status} AND D.DO_DATE LIKE '9999-01-%')
        )
        ORDER BY
        D.TASK_ORDER;
    </select>

    <!--<update id="updateTask" parameterType="taskhubdto">
        UPDATE TASK
            SET
            TASK_CONTENT = #{task_content},
            DUE_DATE = CASE
                        WHEN #{due_date} IS NULL OR #{due_date} = '' THEN NULL
                        ELSE #{due_date}
                        END,
            TASK_STATUS = #{task_status},
            TASK_MEMO   = #{task_memo},
            WORK_ID = CASE
                        WHEN #{work_id} IS NULL OR #{work_id} = '' THEN NULL
                        ELSE #{work_id}
                        END&lt;!&ndash;,
            CATEGORY_ID = CASE
                        WHEN #{category_id} IS NULL OR #{category_id} = '' THEN NULL
                        ELSE #{category_id}
                        END&ndash;&gt;
        WHERE TASK_ID = #{task_id}
    </update>-->
    <update id="updateTask" parameterType="taskhubdto">
        UPDATE TASK
        <set>
            <if test="task_content != null">
                TASK_CONTENT = #{task_content},
            </if>
            <if test="due_date != null and due_date != ''">
                DUE_DATE = #{due_date},
            </if>
            <if test="task_status != null">
                TASK_STATUS = #{task_status},
            </if>
            <if test="task_memo != null">
                TASK_MEMO = #{task_memo},
            </if>
            <if test="work_id != null and work_id != ''">
                WORK_ID = #{work_id},
            </if>
        </set>
        WHERE TASK_ID = #{task_id}
    </update>



    <update id="updateDoDateTaskDone" parameterType="map">
        UPDATE DODATES
        SET
        TASK_DONE = #{task_done}
        WHERE TASK_ID = #{task_id}
          AND DO_DATE = #{do_date}
    </update>

    <update id="updateWork" parameterType="taskhubdto">
        UPDATE WORK
        SET
        WORK_NAME = #{work_name}<!--,
        DUE_DATE = CASE
        WHEN #{due_date} IS NULL OR #{due_date} = '' THEN NULL
        ELSE #{due_date}
        END,
        TASK_STATUS = #{task_status},
        TASK_MEMO   = #{task_memo},
        WORK_ID = CASE
        WHEN #{work_id} IS NULL OR #{work_id} = '' THEN NULL
        ELSE #{work_id}
        END--><!--,
            CATEGORY_ID = CASE
                        WHEN #{category_id} IS NULL OR #{category_id} = '' THEN NULL
                        ELSE #{category_id}
                        END-->
        WHERE WORK_ID = #{work_id}
    </update>

    <update id="clearParent" parameterType="Long">
        UPDATE TASK
        SET
        PARENT_TASK = NULL
        WHERE TASK_ID = #{task_id}
    </update>

    <update id="updateTaskDeletingWorkId" parameterType="Long">
        UPDATE TASK
        SET
        WORK_ID = NULL
        WHERE WORK_ID = #{work_id}
    </update>

    <update id="updateStatus" parameterType="map">
        UPDATE TASK
        SET
        TASK_STATUS = #{task_status}
        WHERE TASK_ID = #{task_id}
    </update>

    <select id="getOldDoDateAndOrder" parameterType="String" resultType="map">
        SELECT DO_DATE AS old_do_date, TASK_ORDER AS old_order_idx
        FROM DODATES
        WHERE TASK_ID = #{task_id}
        LIMIT 1;
    </select>

    <select id="getMaxIdxOfNewDate" parameterType="map" resultType="String">
        SELECT COALESCE(MAX(D.TASK_ORDER) + 1, 0) AS new_idx
        FROM TASK T JOIN DODATES D
             ON T.TASK_ID = D.TASK_ID
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.DO_DATE = #{newDoDate};
    </select>

    <update id="orderMinus1BeforeDeletion" parameterType="taskhubdto">
        <!-- [case1: 이동하는 날짜그룹 상이] 1. taskid의 원래 do_date에서 현 task_id가 빠진 채로 다시 인덱싱하여 TASK_ORDER 부여 -->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET D.TASK_ORDER = D.TASK_ORDER - 1
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.DO_DATE = #{old_do_date}
        AND D.TASK_ORDER <![CDATA[>]]> #{old_order_idx};
    </update>

    <update id="orderPlus1BeforeInsertion" parameterType="taskhubdto">
        <!-- [case1: 이동하는 날짜그룹 상이] 2. taskid가 이동하는 do_date에서 현 task_id가 이동하려는 인덱스 이하의 데이터들의 task_order 1 증가 -->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET D.TASK_ORDER = D.TASK_ORDER + 1
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.DO_DATE = #{new_do_date}
        AND D.TASK_ORDER >= #{new_order_idx};
    </update>

    <update id="updateOrderAndDoDateOfTask" parameterType="taskhubdto">
        <!-- [case1 & case2] 현재 taskid의 do_date와 task_order 변경-->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET
        D.DO_DATE = #{new_do_date},
        D.TASK_ORDER = #{new_order_idx}
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.TASK_ID = #{task_id}
        AND D.DO_DATE = #{old_do_date};
        <!--INSERT INTO DODATES (DO_DATE, TASK_ID, TASK_ORDER) VALUES
        (#{new_do_date},#{task_id},#{task_order_idx})-->
    </update>

    <update id="updateOrderAndDoDateInSameDateDown" parameterType="taskhubdto">
        <!-- [case2: 이동하는 날짜그룹 동일] 1. Moving Downwards -->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET D.TASK_ORDER = D.TASK_ORDER - 1
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.DO_DATE = #{new_do_date}
        AND D.TASK_ORDER > #{old_order_idx}
        AND D.TASK_ORDER <![CDATA[<=]]> #{new_order_idx};
    </update>

    <update id="updateOrderAndDoDateInSameDateUp" parameterType="taskhubdto">
        <!-- [case2: 이동하는 날짜그룹 동일] 2. Moving Upwards -->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET D.TASK_ORDER = D.TASK_ORDER + 1
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.DO_DATE = #{new_do_date}
        AND D.TASK_ORDER >= #{new_order_idx}
        AND D.TASK_ORDER <![CDATA[<]]> #{old_order_idx};
    </update>

    <update id="assignTempOrderById" parameterType="String">
        -- 1. Temporarily set TASK_ORDER for the specified TASK_ID to a placeholder value
        UPDATE DODATES
        SET TASK_ORDER = 999999
        WHERE TASK_ID = #{task_id};
    </update>

    <update id="assignTempOrderByIdDate" parameterType="map">
        -- 1. Temporarily set TASK_ORDER for the specified TASK_ID to a placeholder value
        UPDATE DODATES
        SET TASK_ORDER = 999999
        WHERE TASK_ID = #{task_id}
          AND DO_DATE = #{do_date};
    </update>

    <update id="rearrangeOrderById" parameterType="map">
        -- Step 1: Define the CTE to calculate the new task order
        WITH OrderedTasks AS (
            SELECT
                D.DO_DATE,
                D.TASK_ID,
                CASE
                WHEN @current_do_date = D.DO_DATE THEN @row_number := @row_number + 1
                ELSE @row_number := 0
                END AS new_task_order,
                @current_do_date := D.DO_DATE
            FROM
            (SELECT @row_number := -1, @current_do_date := NULL) AS vars,  -- Initialize variables
            (SELECT D.* FROM DODATES D JOIN TASK T ON D.TASK_ID = T.TASK_ID
              WHERE 1=1
                <include refid="sessionUserId"/>
                AND D.DO_DATE IN (SELECT DO_DATE FROM DODATES WHERE TASK_ID = #{task_id})
                AND D.TASK_ID != #{task_id}
              ORDER BY D.DO_DATE, D.TASK_ORDER
            ) D
        )
        -- Step 2: Update the DODATES table with the new task order values
        UPDATE DODATES D JOIN OrderedTasks OT
               ON D.DO_DATE = OT.DO_DATE
        AND D.TASK_ID = OT.TASK_ID
        JOIN TASK T ON D.TASK_ID = T.TASK_ID  -- Join with TASK to filter by user_id
        SET D.TASK_ORDER = OT.new_task_order
        WHERE 1=1
        <include refid="sessionUserId"/>;  -- Ensure only rows for the specified user_id are updated

    </update>

    <update id="rearrangeOrderByIdDate" parameterType="map">
        -- Step 1: Define the CTE to calculate the new task order
        WITH OrderedTasks AS (
        SELECT
        D.DO_DATE,
        D.TASK_ID,
        CASE
        WHEN @current_do_date = D.DO_DATE THEN @row_number := @row_number + 1
        ELSE @row_number := 0
        END AS new_task_order,
        @current_do_date := D.DO_DATE
        FROM
        (SELECT @row_number := -1, @current_do_date := NULL) AS vars,  -- Initialize variables
        (SELECT D.*
        FROM DODATES D
        JOIN TASK T ON D.TASK_ID = T.TASK_ID
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.DO_DATE = #{do_date}  -- Use the provided do_date parameter
        AND D.TASK_ID != #{task_id}  -- Exclude the specific task_id
        ORDER BY D.DO_DATE, D.TASK_ORDER
        ) D
        )
        -- Step 2: Update the DODATES table with the new task order values
        UPDATE DODATES D
        JOIN OrderedTasks OT ON D.DO_DATE = OT.DO_DATE
        AND D.TASK_ID = OT.TASK_ID
        JOIN TASK T ON D.TASK_ID = T.TASK_ID  -- Join with TASK to filter by user_id
        SET D.TASK_ORDER = OT.new_task_order
        WHERE 1=1
        AND D.DO_DATE = #{do_date}  -- Ensure only rows for the provided do_date are updated
        <include refid="sessionUserId"/>;  -- Ensure only rows for the specified user_id are updated

    </update>

    <update id="updateDetailDoDate" parameterType="map">
        UPDATE DODATES
           SET DO_DATE    = #{do_date},
               TASK_ORDER = #{task_order}
         WHERE TASK_ID    = #{task_id}
           AND DO_DATE    = #{old_date}
    </update>

    <delete id="deleteTask" parameterType="String">
        DELETE FROM TASK WHERE TASK_ID = #{task_id}
    </delete>

    <delete id="deleteWork" parameterType="map">
        DELETE FROM WORK WHERE WORK_ID = #{work_id} AND USER_ID = #{user_id}
    </delete>

    <select id="getCategories" resultType="taskhubdto">
        SELECT T.CATEGORY_ID, T.CATEGORY_NAME, T.CATEGORY_ORDER, T.USER_ID
        FROM CATEGORY T
        WHERE 1=1
        <include refid="sessionUserId"/>
        ORDER BY T.CATEGORY_ORDER;
    </select>

    <select id="findAllUsers" resultType="Long">
        SELECT userId
        FROM USER
    </select>

    <select id="findUncompletedUndone" parameterType="Long" resultType="taskhubdto">
        <!--SELECT DISTINCT D.task_id
        FROM
        DODATES D
        WHERE   D.do_date <![CDATA[<]]> CURDATE()
        &#45;&#45;	AND D.do_date NOT LIKE '9999%'
        AND D.TASK_ID IN (SELECT T.TASK_ID
        FROM
        TASK T
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND T.TASK_STATUS NOT IN (2, 3) &lt;!&ndash; Complete, Canceled&ndash;&gt;
        )-->

        SELECT TASK_ID, DDATE AS DO_DATE
        FROM (
                SELECT
                MAX(D.do_date) AS DDATE,
                D.task_id AS TASK_ID,
                D.TASK_DONE AS TASK_DONE,
                D.TASK_ORDER AS TASK_ORDER
                FROM DODATES D
                WHERE D.TASK_ID IN (SELECT T.TASK_ID
                FROM TASK T
                WHERE 1=1
                <include refid="sessionUserId"/>
                AND T.TASK_STATUS NOT IN (2, 3)  -- 2: Completed, 3: Canceled
                )
        GROUP BY D.task_id
        ) AS LatestTask
        WHERE LatestTask.DDATE <![CDATA[<]]> CURDATE()
          AND (SELECT DD.TASK_DONE FROM DODATES DD
                WHERE DD.TASK_ID = LatestTask.TASK_ID
                  AND DD.DO_DATE = LatestTask.DDATE) != 2 -- 2: Done
        ORDER BY LatestTask.DDATE, LatestTask.TASK_ORDER
        ;
    </select>

    <select id="findUncompletedDone" parameterType="Long" resultType="String">
        SELECT TASK_ID
        FROM (
                SELECT
                MAX(D.do_date) AS DDATE,
                D.task_id AS TASK_ID,
                D.TASK_DONE AS TASK_DONE,
                D.TASK_ORDER AS TASK_ORDER
                FROM DODATES D
                WHERE D.TASK_ID IN (SELECT T.TASK_ID
                FROM TASK T
                WHERE 1=1
                <include refid="sessionUserId"/>
                AND T.TASK_STATUS NOT IN (2, 3)  -- 2: Completed, 3: Canceled
                )
        GROUP BY D.task_id
        ) AS LatestTask
        WHERE LatestTask.DDATE <![CDATA[<]]> CURDATE()
        AND (SELECT DD.TASK_DONE FROM DODATES DD
              WHERE DD.TASK_ID = LatestTask.TASK_ID
                AND DD.DO_DATE = LatestTask.DDATE) = 2 -- 2: Done
        ORDER BY LatestTask.DDATE, LatestTask.TASK_ORDER
        ;
    </select>

    <select id="isTaskExecutedToday" parameterType="String" resultType="boolean">
        SELECT COUNT(*)
        FROM task_execution_log
        WHERE 1=1 <!--user_id = #{userId}-->
        AND execution_date = #{today}
    </select>

    <insert id="saveExecutionLog" parameterType="map">
        INSERT INTO task_execution_log (execution_date)
        VALUES (#{today})
    </insert>

    <select id="isDuplicateOnSameDate" parameterType="map" resultType="int">
        SELECT COUNT(*)
        FROM DODATES
        WHERE 1=1
        AND TASK_ID = #{task_id}
        AND DO_DATE = #{do_date}
    </select>

    <select id="isOnlyDoDate" parameterType="String" resultType="int">
        SELECT COUNT(*)
        FROM DODATES
        WHERE 1=1
        AND TASK_ID = #{task_id}
    </select>

    <select id="isDone" parameterType="map" resultType="String">
        SELECT TASK_DONE
        FROM DODATES
        WHERE 1=1
        AND TASK_ID = #{task_id}
        AND DO_DATE = #{do_date}
    </select>

</mapper>

