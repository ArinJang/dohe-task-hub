<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="Taskhub">

    <sql id="sessionUserId">
        AND T.USER_ID = #{user_id}
    </sql>

    <select id="callInsertTaskAndDoDates" parameterType="map">
        CALL InsertTaskAndDoDates(
        #{task_content},
        #{do_dates},
        <!--#{task_order},-->
        #{user_id},
        #{parent_task_id},
        #{category_id},
        #{work_id},
        #{original_id}
        )
    </select>

    <insert id="insertTask">
        INSERT INTO TASK (TASK_CONTENT, DO_DATES, USER_ID)
        VALUES (#{routine_content}, #{routine_group}, #{user_id});
    </insert>

    <insert id="insertWork">
        INSERT INTO WORK (WORK_NAME, USER_ID, CATEGORY_ID)
        VALUES (#{work_name}
              , #{user_id}
              , #{category_id});
    </insert>

    <insert id="insertCategory">
        INSERT INTO CATEGORY (CATEGORY_NAME, USER_ID)
        VALUES (#{category_name}
        , #{user_id});
    </insert>

    <select id="getMaxRoutineOrder" parameterType="String" resultType="int">
        SELECT COALESCE(MAX(ROUTINE_ORDER) + 1, 0)
        FROM ROUTINE
        WHERE ROUTINE_GROUP = #{routine_group}
    </select>

    <insert id="insertRoutine">
        INSERT INTO ROUTINE (ROUTINE_CONTENT, ROUTINE_GROUP, USER_ID, ROUTINE_ORDER)
        VALUES (#{routine_content}, #{routine_group}, #{user_id}, #{routine_order} );
    </insert>

    <select id="findFirstGroup" parameterType="Long" resultType="Long">
        SELECT
        R.ROUTINE_ID
        FROM ROUTINE R
        WHERE 1=1
        AND R.USER_ID = #{user_id}
        AND R.ROUTINE_GROUP IS NULL
        ORDER BY R.ROUTINE_ID
        LIMIT 1;  -- 가장 첫 번째 결과만 가져오기
    </select>

    <select id="findRoutines" parameterType="Long" resultType="taskhubdto">
        SELECT
        R.ROUTINE_ID AS ROUTINE_ID,
        R.ROUTINE_CONTENT AS ROUTINE_CONTENT,
        R.ROUTINE_GROUP AS ROUTINE_GROUP,
        (SELECT ROUTINE_CONTENT FROM ROUTINE WHERE ROUTINE_ID = R.ROUTINE_GROUP) AS GROUP_CONTENT,
        R.REPETITION_CYCLE,
        R.REPETITION_DAY,
<!--        R.THIS_NEXT,-->
        R.CREATE_DATE,
        R.ROUTINE_ORDER
        FROM ROUTINE R
        WHERE 1=1
        AND R.USER_ID = #{user_id}
        AND R.ROUTINE_GROUP IS NOT NULL

        UNION

        SELECT
        NULL AS ROUTINE_ID,
        NULL AS ROUTINE_CONTENT,
        E.ROUTINE_ID AS ROUTINE_GROUP,
        E.ROUTINE_CONTENT AS GROUP_CONTENT,
        NULL AS REPETITION_CYCLE,
        NULL AS REPETITION_DAY,
<!--        NULL AS THIS_NEXT,-->
        NULL AS CREATE_DATE,
        E.ROUTINE_ORDER
        FROM ROUTINE E
        WHERE 1=1
        AND E.USER_ID = #{user_id}
        AND (E.ROUTINE_GROUP IS NULL AND (SELECT COUNT(W.ROUTINE_ID) FROM ROUTINE W WHERE W.ROUTINE_GROUP = E.ROUTINE_ID) = 0)

        ORDER BY ROUTINE_ORDER <!--, ROUTINE_ID, CREATE_DATE-->
    </select>

    <delete id="deleteDoDatesByTaskId" parameterType="string">
        DELETE FROM DODATES WHERE TASK_ID = #{taskId}
    </delete>

    <delete id="deleteDoDatesByTaskId2" parameterType="map">
        DELETE FROM DODATES WHERE TASK_ID = #{task_id} AND DO_DATE = #{do_date}
    </delete>

    <!-- 1. TASK_ORDER 값을 계산 -->
    <select id="getMaxTaskOrder" parameterType="map" resultType="int">
        SELECT COALESCE(MAX(D.TASK_ORDER) + 1, 0)
        FROM DODATES D JOIN TASK T
             ON T.TASK_ID = D.TASK_ID
        WHERE 1=1
        <include refid="sessionUserId" />
        AND D.DO_DATE = #{do_date}
        AND T.TASK_STATUS NOT IN (2,3)
    </select>

    <!-- 2. INSERT 실행 -->
    <insert id="insertDoDate">
        INSERT INTO DODATES (TASK_ID, DO_DATE, TASK_ORDER
                            <if test="task_done != null">
                                , TASK_DONE
                            </if>
                            )
        VALUES (#{task_id}, #{do_date}, #{task_order}
                <if test="task_done != null">
                    , #{task_done}
                </if>
                );
    </insert>

    <select id="findAll" parameterType="map" resultType="taskhubdto">
        SELECT
            T.TASK_ID,
            T.TASK_CONTENT,
            T.USER_ID,
            COALESCE(CONCAT('(', W.WORK_NAME, ')'), '') AS WORK_NAME,
            DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
            CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
            <!--CASE
            WHEN D.DO_DATE = '9999-12-31' THEN NULL
            ELSE D.DO_DATE
            END AS DO_DATE,-->
            D.DO_DATE,
            D.TASK_ORDER,
            D.TASK_DONE,
            T.TASK_STATUS,
            CASE WHEN T.PARENT_TASK IS NOT NULL THEN
                 (SELECT P.TASK_CONTENT FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
                 ELSE '0'
                 END AS PARENT_TASK_CONTENT,
            CASE WHEN T.DUE_DATE <![CDATA[<=]]> CURDATE() AND T.TASK_STATUS NOT IN (2, 3) THEN 1
                 ELSE 0
                 END AS IS_OVERDUE
        FROM TASK T RIGHT JOIN DODATES D
             ON T.task_id = D.task_id
             LEFT JOIN WORK W ON T.WORK_ID = W.WORK_ID
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.do_date = '9999-12-31'
        AND T.TASK_STATUS NOT IN (4, 5, 6)
        <if test="hide_completed != null and hide_completed != ''">
        AND T.TASK_STATUS NOT IN (2, 3)
        </if>
        ORDER BY
        D.TASK_ORDER IS NULL, D.TASK_ORDER, T.LAST_MODIFIED;

    </select>

    <select id="findAssignedToMe" parameterType="Long" resultType="taskhubdto">
        SELECT
            T.TASK_ID,
            T.TASK_CONTENT,
            T.USER_ID,
            COALESCE(CONCAT('(', W.WORK_NAME, ')'), '') AS WORK_NAME,
            DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
            CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
            <!--CASE
            WHEN D.DO_DATE = '9999-12-31' THEN NULL
            ELSE D.DO_DATE
            END AS DO_DATE,-->
            D.DO_DATE,
            D.TASK_ORDER,
            D.TASK_DONE,
            T.TASK_STATUS,
            CASE WHEN T.PARENT_TASK IS NOT NULL THEN
            (SELECT P.TASK_CONTENT FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
            ELSE '0'
            END AS PARENT_TASK_CONTENT,
            CASE WHEN T.DUE_DATE <![CDATA[<=]]> CURDATE() AND T.TASK_STATUS NOT IN (2, 3) THEN 1
            ELSE 0
            END AS IS_OVERDUE
        <!--,
            CASE WHEN T.ASSIGNEE_ID IS NULL OR T.ASSIGNEE_ID = '' OR T.USER_ID = #{user_id} THEN 0
            ELSE 1 END AS IS_ASSIGNED_TO_ME-->
        FROM TASK T RIGHT JOIN DODATES D
        ON T.task_id = D.task_id
        LEFT JOIN WORK W ON T.WORK_ID = W.WORK_ID
        WHERE T.ASSIGNEE_ID = #{user_id}
          AND T.TASK_STATUS = 5
        ORDER BY D.TASK_ORDER;
    </select>

    <select id="findTaskContent" parameterType="Long" resultType="taskhubdto">
        SELECT
        T.TASK_CONTENT,
        T.TASK_STATUS
        FROM TASK T
        WHERE 1=1
        AND T.TASK_ID = #{task_id}
        ORDER BY T.TASK_ID;
    </select>

    <select id="findByDoDates" parameterType="taskhubdto" resultType="taskhubdto">
        <!--WITH RECURSIVE numbers AS (SELECT
                                    1 AS num
                                    UNION ALL
                                    SELECT
                                    num + 1
                                    FROM numbers
                                    WHERE num <![CDATA[<]]> 100 ),
        split_dates AS (SELECT
                        T.TASK_ID,
                        T.TASK_CONTENT,
                        CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
                        T.DUE_DATE AS ORI_DUE_DATE,
                        T.TASK_STATUS,
                        COALESCE(CONCAT('(', W.WORK_NAME, ')'), '') AS WORK_NAME,
                        D.DO_DATE,
                        D.TASK_DONE,
                        D.TASK_ORDER
                        FROM
                        TASK T
                        JOIN DODATES D
                        ON
                        T.TASK_ID = D.TASK_ID
                        LEFT JOIN WORK W ON
                        T.WORK_ID = W.WORK_ID
                        WHERE 1 = 1
                        <include refid = "sessionUserId" />
                        AND D.DO_DATE BETWEEN #{mon} AND #{sun} ),
        filtered_dates AS (SELECT
                                TASK_ID,
                                TASK_CONTENT,
                                DUE_DATE,
                                TASK_DONE,
                                TASK_STATUS,
                                WORK_NAME,
                                DO_DATE,
                                TASK_ORDER,
                                ORI_DUE_DATE
                            FROM split_dates )
        SELECT
            TASK_ID,
            TASK_CONTENT,
            DUE_DATE,
            TASK_DONE,
            TASK_STATUS,
            WORK_NAME,
            UPPER(DATE_FORMAT(DO_DATE, '%a')) AS day_of_week,
            CASE WHEN ORI_DUE_DATE <![CDATA[<=]]> CURDATE() AND TASK_STATUS NOT IN (2, 3) THEN 1
                 ELSE 0
                 END AS IS_OVERDUE
        FROM filtered_dates
        ORDER BY
        TASK_ORDER,
        TASK_STATUS,
        TASK_ID DESC;-->
        SELECT
        T.TASK_ID,
        T.TASK_CONTENT,
        CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
        D.TASK_DONE,
        T.TASK_STATUS,
        CASE WHEN T.PARENT_TASK IS NOT NULL THEN
        (SELECT P.TASK_CONTENT FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
        ELSE '0'
        END AS PARENT_TASK_CONTENT,
        COALESCE(CONCAT('(', (SELECT WORK_NAME FROM WORK WHERE WORK_ID = T.WORK_ID), ')'), '') AS WORK_NAME,
        UPPER(DATE_FORMAT(D.DO_DATE, '%a')) AS day_of_week,
        CASE    WHEN T.DUE_DATE <![CDATA[<=]]> CURDATE()
                AND T.TASK_STATUS NOT IN (2, 3) THEN 1
                ELSE 0
                END                         AS IS_OVERDUE,
        D.DO_DATE
        FROM TASK T RIGHT JOIN DODATES D
             ON T.task_id = D.task_id
        WHERE 1 = 1
        <include refid = "sessionUserId" />
        AND D.do_date BETWEEN #{mon} AND #{sun}
        <if test="hide_completed != null">
        AND T.TASK_STATUS NOT IN (2, 3)
        </if>
        ORDER BY
        D.TASK_ORDER IS NULL, D.TASK_ORDER, T.LAST_MODIFIED
    </select>

    <!--<select id="findByCategory" parameterType="String" resultType="taskhubdto">
        SELECT
            T.TASK_ID,
            T.TASK_CONTENT,
            CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
            T.TASK_STATUS,
            CASE WHEN T.PARENT_TASK IS NOT NULL THEN
            (SELECT P.TASK_CONTENT FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
            ELSE '0'
            END AS PARENT_TASK_CONTENT,
            COALESCE(CONCAT('(', (SELECT WORK_NAME FROM WORK WHERE WORK_ID = T.WORK_ID), ')'), '') AS WORK_NAME,
            CASE    WHEN T.DUE_DATE <![CDATA[<=]]> CURDATE()
            AND T.TASK_STATUS NOT IN (2, 3) THEN 1
            ELSE 0
            END                         AS IS_OVERDUE,
        FROM TASK T RIGHT JOIN CATEGORY C
            ON T.category_id = C.category_id
        WHERE 1 = 1
          AND T.WORK_ID IN (SELECT WORK_ID FROM WORK WHERE CATEGORY_ID IS NULL)
        ORDER BY T.TASK_ORDER,
        T.TASK_STATUS
        &lt;!&ndash; 추가 필요!!!!!!!!!! &ndash;&gt;
    </select>-->

    <select id="findByWork" parameterType="map" resultType="taskhubdto">
        <!--SELECT
                T.TASK_ID,
                T.TASK_CONTENT,
                T.USER_ID,
                IFNULL(W.WORK_ID, 999999) AS WORK_ID,
                IFNULL(W.WORK_NAME, '(work not assigned)') AS WORK_NAME,
                DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
                CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
                T.TASK_STATUS,
                CASE WHEN T.PARENT_TASK IS NOT NULL THEN
                (SELECT P.TASK_CONTENT FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
                ELSE '0'
                END AS PARENT_TASK_CONTENT,
                CASE WHEN T.DUE_DATE <![CDATA[<=]]> CURDATE() AND T.TASK_STATUS NOT IN (2, 3) THEN 1
                     ELSE 0
                     END AS IS_OVERDUE
          FROM TASK T LEFT JOIN WORK W ON T.WORK_ID = W.WORK_ID
         WHERE 1=1
           &lt;!&ndash;<include refid="sessionUserId"/>&ndash;&gt;
           AND T.USER_ID = #{user_id}
           &lt;!&ndash;AND T.WORK_ID IS NOT NULL&ndash;&gt;
        <if test="category_id == null">
           &lt;!&ndash;AND (W.WORK_ID IS NOT NULL)&ndash;&gt;
        </if>
        <if test="category_id != null">
           AND (W.CATEGORY_ID = #{category_id} OR T.CATEGORY_ID = #{category_id})
        </if>
         ORDER BY
                CASE WHEN W.WORK_ID IS NULL THEN 1 ELSE 0 END, &#45;&#45; NULL인 경우 맨 끝으로
                W.WORK_ID, T.TASK_ORDER;-->


        SELECT
        T.TASK_ID,
        T.TASK_CONTENT,
        T.USER_ID,
        COALESCE(W.WORK_ID, 999999) AS WORK_ID, -- NULL인 WORK_ID는 999999로 대체
        COALESCE(W.WORK_NAME, '(work not assigned)') AS WORK_NAME,
        DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
        CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
        T.TASK_STATUS,
        CASE WHEN T.PARENT_TASK IS NOT NULL THEN
        (SELECT P.TASK_CONTENT FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
        ELSE '0'
        END AS PARENT_TASK_CONTENT,
        CASE WHEN T.DUE_DATE <![CDATA[<=]]> CURDATE() AND T.TASK_STATUS NOT IN (2, 3) THEN 1
        ELSE 0
        END AS IS_OVERDUE
        FROM
        -- LEFT JOIN을 이용하여 TASK와 WORK를 결합
        TASK T LEFT JOIN WORK W ON T.WORK_ID = W.WORK_ID
        WHERE 1=1
        AND T.USER_ID = #{user_id}
        AND (W.WORK_STATUS != 2 OR W.WORK_STATUS IS NULL)
        <if test="category_id == null">
            AND T.WORK_ID IS NOT NULL
        </if>
        <if test="category_id != null">
            AND (W.CATEGORY_ID = #{category_id} OR T.CATEGORY_ID = #{category_id})
        </if>

        UNION

        SELECT
        NULL AS TASK_ID,  -- TASK가 없으므로 NULL
        NULL AS TASK_CONTENT,
        W.USER_ID,  -- WORK의 USER_ID 사용
        W.WORK_ID,
        W.WORK_NAME,
        NULL AS CREATE_DATE,
        NULL AS DUE_DATE,
        NULL AS TASK_STATUS,
        '0' AS PARENT_TASK_CONTENT,
        0 AS IS_OVERDUE
        FROM
        -- RIGHT JOIN을 이용하여 TASK가 없는 WORK도 가져옴
        WORK W LEFT JOIN TASK T ON W.WORK_ID = T.WORK_ID
        WHERE T.TASK_ID IS NULL -- TASK가 없는 WORK만 선택
        AND W.USER_ID = #{user_id}
        AND (W.WORK_STATUS != 2 OR W.WORK_STATUS IS NULL)
        <if test="category_id != null">
            AND (W.CATEGORY_ID = #{category_id} OR T.CATEGORY_ID = #{category_id})
        </if>

        ORDER BY
        CASE WHEN WORK_ID = 999999 THEN 1 ELSE 0 END,  -- NULL인 경우 맨 끝으로 정렬
        WORK_ID, CREATE_DATE;
    </select>

    <select id="findCompletedTasksByWork" parameterType="Long" resultType="taskhubdto">
        SELECT
        T.TASK_ID,
        T.TASK_CONTENT,
        T.USER_ID,
        COALESCE(W.WORK_ID, 999999) AS WORK_ID, -- NULL인 WORK_ID는 999999로 대체
        COALESCE(W.WORK_NAME, '(work not assigned)') AS WORK_NAME,
        DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
        W.LAST_MODIFIED,
        CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
        T.TASK_STATUS,
        CASE WHEN T.PARENT_TASK IS NOT NULL THEN
        (SELECT P.TASK_CONTENT FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
        ELSE '0'
        END AS PARENT_TASK_CONTENT,
        CASE WHEN T.DUE_DATE <![CDATA[<=]]> CURDATE() AND T.TASK_STATUS NOT IN (2, 3) THEN 1
        ELSE 0
        END AS IS_OVERDUE
        FROM
        -- LEFT JOIN을 이용하여 TASK와 WORK를 결합
        TASK T LEFT JOIN WORK W ON T.WORK_ID = W.WORK_ID
        WHERE 1=1
        AND T.USER_ID = #{user_id}
        AND T.WORK_ID IS NOT NULL
        AND W.WORK_STATUS = 2
        UNION

        SELECT
        NULL AS TASK_ID,  -- TASK가 없으므로 NULL
        NULL AS TASK_CONTENT,
        W.USER_ID,  -- WORK의 USER_ID 사용
        W.WORK_ID,
        W.WORK_NAME,
        NULL AS CREATE_DATE,
        W.LAST_MODIFIED,
        NULL AS DUE_DATE,
        NULL AS TASK_STATUS,
        '0' AS PARENT_TASK_CONTENT,
        0 AS IS_OVERDUE
        FROM
        -- RIGHT JOIN을 이용하여 TASK가 없는 WORK도 가져옴
        WORK W LEFT JOIN TASK T ON W.WORK_ID = T.WORK_ID
        WHERE T.TASK_ID IS NULL -- TASK가 없는 WORK만 선택
        AND W.USER_ID = #{user_id}
        AND W.WORK_STATUS = 2

        ORDER BY LAST_MODIFIED
    </select>

    <select id="findWorks" parameterType="Long" resultType="taskhubdto">
        SELECT
                W.WORK_ID,
                W.WORK_NAME AS WORK_NAME
        FROM WORK W
        WHERE 1=1
        AND W.USER_ID = #{user_id}
        <if test="category_id != 'null' and category_id != null and category_id != '' and category_id != 'undefined'">
            AND W.CATEGORY_ID = #{category_id}
        </if>
        ORDER BY W.WORK_ID;
    </select>

    <select id="findGroups" parameterType="Long" resultType="taskhubdto">
        SELECT ROUTINE_ID, ROUTINE_CONTENT
          FROM ROUTINE
         WHERE 1=1
           AND USER_ID = #{user_id}
           AND ROUTINE_GROUP IS NULL
         ORDER BY ROUTINE_ID;
    </select>

    <select id="findUsers" parameterType="Long" resultType="taskhubdto">
        SELECT userId AS ASSIGNEE_ID,
               userName AS ASSIGNEE_NAME
          FROM USER
         WHERE 1=1
           AND userId != #{user_id}
         ORDER BY userId;
    </select>

    <select id="findContentById" parameterType="Long" resultType="String">
        SELECT TASK_CONTENT
          FROM TASK
         WHERE TASK_ID = #{task_id}
    </select>

    <select id="findById" parameterType="map" resultType="taskhubdto">
        SELECT
        T.TASK_ID,
        T.TASK_CONTENT,
        T.TASK_STATUS,
        T.TASK_ORDER,
        <!--T.TASK_MEMO,-->
        CASE WHEN T.PARENT_TASK IS NOT NULL THEN
             (SELECT P.TASK_MEMO FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
             ELSE T.TASK_MEMO
             END AS TASK_MEMO,
        T.ASSIGNEE_ID,
        CASE WHEN T.TASK_STATUS = 5 AND T.ASSIGNEE_ID IS NOT NULL THEN
             (SELECT userName FROM USER WHERE userId = T.ASSIGNEE_ID)
             ELSE NULL
             END AS ASSIGNEE_NAME,
        T.CATEGORY_ID AS CATEGORY_ID,
<!--        (SELECT CATEGORY_NAME FROM CATEGORY WHERE CATEGORY_ID = T.CATEGORY_ID) AS CATEGORY_NAME,-->
        T.WORK_ID AS WORK_ID,
        (SELECT W.WORK_NAME FROM WORK W WHERE W.WORK_ID = T.WORK_ID) AS WORK_NAME,
        T.USER_ID,
        DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
        DATE_FORMAT(T.DUE_DATE, '%Y-%m-%d') AS DUE_DATE,
        UPPER(DATE_FORMAT(T.DUE_DATE, '%a')) AS day_of_week,
        IFNULL(
                (SELECT GROUP_CONCAT(
                                    CASE
                                    WHEN D.DO_DATE like '9999%' THEN NULL
                                    ELSE DATE_FORMAT(D.DO_DATE, '%Y-%m-%d')
                                    END
                                    ORDER BY D.DO_DATE ASC
                                    SEPARATOR ','
                                    )
                        FROM DODATES D
                        WHERE D.TASK_ID = T.TASK_ID),
                ''
                ) AS DO_DATES,
        IFNULL(
                (SELECT GROUP_CONCAT(TASK_ID ORDER BY TASK_ID ASC
                                     SEPARATOR ',')
                FROM TASK
                WHERE PARENT_TASK = #{task_id}),
                ''
                ) AS SUB_TASKS,
        IFNULL(PARENT_TASK, 0) AS PARENT_TASK_ID,
        CASE
            WHEN #{do_date} IS NOT NULL THEN
            (SELECT TASK_DONE
            FROM DODATES
            WHERE TASK_ID = #{task_id}
            AND DO_DATE = #{do_date})
            ELSE NULL
            END AS TASK_DONE,
        CASE
            WHEN #{do_date} IS NOT NULL AND #{do_date} NOT LIKE '9999%' THEN
            CONCAT(SUBSTRING(#{do_date}, 6, 2), '/', SUBSTRING(#{do_date}, 9, 2))  -- MM/DD 형식으로 변환
            ELSE NULL
            END AS DO_DATE,
        #{do_date} AS ORI_DO_DATE,
        CASE WHEN T.ASSIGNEE_ID IS NULL OR T.ASSIGNEE_ID = '' THEN 0
             WHEN T.ASSIGNEE_ID != #{user_id} THEN 0
             ELSE 1 END AS IS_ASSIGNED_TO_ME,
        '' AS UPPER_TASK
        FROM
        TASK T
        WHERE
        T.TASK_ID = #{task_id};
    </select>

    <select id="findWorkById" parameterType="Long" resultType="taskhubdto">
        SELECT WORK_ID, WORK_NAME, CATEGORY_ID, USER_ID, LAST_MODIFIED, WORK_STATUS
        FROM
        WORK
        WHERE
        WORK_ID = #{work_id};
    </select>

    <select id="findRoutineById" parameterType="Long" resultType="taskhubdto">
        SELECT
        ROUTINE_ID,
        ROUTINE_CONTENT,
        ROUTINE_GROUP,
        ROUTINE_MEMO,
        THIS_NEXT,
        REPETITION_CYCLE,
            CASE
            WHEN REPETITION_CYCLE IN ('week', 'day') THEN REPETITION_DAY
            ELSE NULL
            END AS ROUTINE_DAY,
            CASE
            WHEN REPETITION_CYCLE = 'month' THEN REPETITION_DAY
            ELSE NULL
            END AS ROUTINE_DATE,
            CASE
            WHEN REPETITION_CYCLE = 'year' THEN SUBSTRING(REPETITION_DAY, 1, 2)
            ELSE NULL
            END AS ROUTINE_MONTH,
            CASE
            WHEN REPETITION_CYCLE = 'year' THEN SUBSTRING(REPETITION_DAY, 4, 2)
            ELSE NULL
            END AS ROUTINE_DATE_OF_MONTH
        FROM
        ROUTINE
        WHERE
        ROUTINE_ID = #{routine_id};

    </select>

    <select id="findLatestDoDateById" parameterType="Long" resultType="String">
        SELECT MAX(DO_DATE) AS DO_DATE
          FROM DODATES
         WHERE TASK_ID = #{task_id};
    </select>

    <select id="findNewId" parameterType="taskhubdto" resultType="int">
        SELECT MAX(T.TASK_ID) FROM TASK T
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND T.DUE_DATE IS NULL
    </select>

    <select id="findNewRoutineId" parameterType="taskhubdto" resultType="int">
        SELECT MAX(T.ROUTINE_ID) FROM ROUTINE T
        WHERE 1=1
        <include refid="sessionUserId"/>
    </select>

    <select id="findByStatus" parameterType="taskhubdto" resultType="taskhubdto">
        <!--<select id="findByStatus" parameterType="taskhubdto" resultType="taskhubdto">
            SELECT
            T.TASK_ID,
            T.TASK_CONTENT,
            T.USER_ID,
            COALESCE(CONCAT('(', W.WORK_NAME, ')'), '') AS WORK_NAME,
            DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
            CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
            D.DO_DATE,
            D.TASK_DONE,
            T.TASK_STATUS,
            CASE WHEN T.PARENT_TASK IS NOT NULL THEN
            (SELECT P.TASK_CONTENT FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
            ELSE '0'
            END AS PARENT_TASK_CONTENT,
            CASE WHEN T.DUE_DATE <![CDATA[<=]]> CURDATE() AND T.TASK_STATUS NOT IN (2, 3) THEN 1
            ELSE 0
            END AS IS_OVERDUE
            FROM TASK T     RIGHT JOIN DODATES D ON T.TASK_ID = D.TASK_ID
            LEFT JOIN  WORK W    ON T.WORK_ID = W.WORK_ID
            WHERE
            1=1
            <include refid="sessionUserId"/>
            <if test="task_status == 2">
                AND T.TASK_STATUS = #{task_status}
            </if>
            <if test="task_status != 2">
                AND T.TASK_STATUS = #{task_status}
                AND D.DO_DATE LIKE '9999-01-%'
            </if>
            ORDER BY
            <if test="task_status == 2">
                T.LAST_MODIFIED DESC,
            </if>
            D.TASK_ORDER;
        </select>
-->
        SELECT
            T.TASK_ID,
            T.TASK_CONTENT,
            T.USER_ID,
            COALESCE(CONCAT('(', W.WORK_NAME, ')'), '') AS WORK_NAME,
            DATE_FORMAT(T.CREATE_DATE, '%Y-%m-%d') AS CREATE_DATE,
            CONCAT('- ', DATE_FORMAT(T.DUE_DATE, '%m/%d')) AS DUE_DATE,
            D.DO_DATE,
            D.TASK_DONE,
            T.TASK_STATUS,
            CASE
            WHEN T.PARENT_TASK IS NOT NULL THEN (SELECT P.TASK_CONTENT FROM TASK P WHERE P.TASK_ID = T.PARENT_TASK)
            ELSE '0'
            END AS PARENT_TASK_CONTENT,
            CASE
            WHEN T.DUE_DATE <![CDATA[<=]]> CURDATE() AND T.TASK_STATUS NOT IN (2, 3) THEN 1
            ELSE 0
            END AS IS_OVERDUE,

            -- task_status가 2인 경우 LAST_MODIFIED의 연-월 값을 반환
            CASE
            WHEN T.TASK_STATUS = 2 THEN DATE_FORMAT(T.LAST_MODIFIED, '%Y-%m')
            ELSE NULL
            END AS LAST_MODIFIED_MONTH

        FROM TASK T
        RIGHT JOIN DODATES D ON T.TASK_ID = D.TASK_ID
        LEFT JOIN WORK W ON T.WORK_ID = W.WORK_ID
        WHERE
        1=1
        <include refid="sessionUserId"/>

        -- 필터링 로직
        <if test="task_status != null">
            AND T.TASK_STATUS = #{task_status}
        </if>

        ORDER BY
        <if test="task_status == 2">
            T.LAST_MODIFIED DESC,
        </if>
        D.TASK_ORDER;
    </select>

    <!--<update id="updateTask" parameterType="taskhubdto">
        UPDATE TASK
            SET
            TASK_CONTENT = #{task_content},
            DUE_DATE = CASE
                        WHEN #{due_date} IS NULL OR #{due_date} = '' THEN NULL
                        ELSE #{due_date}
                        END,
            TASK_STATUS = #{task_status},
            TASK_MEMO   = #{task_memo},
            WORK_ID = CASE
                        WHEN #{work_id} IS NULL OR #{work_id} = '' THEN NULL
                        ELSE #{work_id}
                        END&lt;!&ndash;,
            CATEGORY_ID = CASE
                        WHEN #{category_id} IS NULL OR #{category_id} = '' THEN NULL
                        ELSE #{category_id}
                        END&ndash;&gt;
        WHERE TASK_ID = #{task_id}
    </update>-->
    <update id="updateTask" parameterType="taskhubdto">
        UPDATE TASK
        <set>
            <if test="task_content != null">
                TASK_CONTENT = #{task_content},
            </if>
            <if test="due_date != null and due_date != ''">
                DUE_DATE = #{due_date},
            </if>
            <if test="task_status != null">
                TASK_STATUS = #{task_status},
            </if>
            <if test="task_memo != null">
                TASK_MEMO = #{task_memo},
            </if>
            <if test="work_id != null and work_id != ''">
                WORK_ID = #{work_id},
                CATEGORY_ID = (SELECT CATEGORY_ID FROM WORK WHERE WORK_ID = #{work_id}),
            </if>
            <if test="work_id == ''">
                WORK_ID = NULL,
                CATEGORY_ID = NULL,
            </if>
            <if test="category_id != null and category_id != ''">
                CATEGORY_ID = #{category_id},
            </if>
            <if test="category_id == ''">
                CATEGORY_ID = NULL,
            </if>
            <if test="assignee_id != null">
                ASSIGNEE_ID = #{assignee_id},
            </if>
        </set>
        WHERE TASK_ID = #{task_id}
    </update>

    <update id="updateDoDateTaskDone" parameterType="map">
        UPDATE DODATES
        SET
        TASK_DONE = #{task_done}
        WHERE TASK_ID = #{task_id}
          AND DO_DATE = #{do_date}
    </update>

    <update id="updateWork" parameterType="taskhubdto">
        UPDATE WORK
        <set>
            <if test="work_name != null">
                WORK_NAME = #{work_name},
            </if>
            <if test="category_id != null and category_id != ''">
                CATEGORY_ID = #{category_id},
            </if>
            <if test="work_status != null">
                WORK_STATUS = #{work_status},
            </if>
        </set>
        WHERE WORK_ID = #{work_id}
    </update>

    <update id="updateCategory" parameterType="taskhubdto">
        UPDATE CATEGORY
        SET
        CATEGORY_NAME = #{category_name}
        WHERE CATEGORY_ID = #{category_id}
    </update>

    <update id="updateRoutine" parameterType="taskhubdto">
        UPDATE ROUTINE
        <set>
            <if test="routine_content != null">
                ROUTINE_CONTENT = #{routine_content},
            </if>
            <if test="repetition_cycle != null and repetition_cycle != ''">
                REPETITION_CYCLE = #{repetition_cycle},
            </if>
            <if test="repetition_cycle == ''">
                REPETITION_CYCLE = NULL,
                REPETITION_DAY = NULL,
            </if>
            <if test="repetition_day != null and repetition_day != ''">
                REPETITION_DAY = #{repetition_day},
            </if>
            <if test="repetition_day == ''">
                REPETITION_DAY = NULL,
            </if>
            <if test="this_next != null and this_next != ''">
                THIS_NEXT = #{this_next},
            </if>
            <if test="routine_group != null">
                ROUTINE_GROUP = #{routine_group},
            </if>
            <if test="routine_memo != null">
                ROUTINE_MEMO = #{routine_memo},
            </if>
        </set>
        WHERE ROUTINE_ID = #{routine_id}
    </update>

    <update id="clearParent" parameterType="Long">
        UPDATE TASK
        SET
        PARENT_TASK = NULL
        WHERE TASK_ID = #{task_id}
    </update>

    <update id="updateTaskDeletingWorkId" parameterType="Long">
        UPDATE TASK
        SET
        WORK_ID = NULL
        WHERE WORK_ID = #{work_id}
    </update>

    <update id="updateStatus" parameterType="map">
        UPDATE TASK
        SET
        TASK_STATUS = #{task_status}
        WHERE TASK_ID = #{task_id}
    </update>

    <select id="getOldDoDateAndOrder" parameterType="String" resultType="map">
        SELECT DO_DATE AS old_do_date, TASK_ORDER AS old_order_idx
        FROM DODATES
        WHERE TASK_ID = #{task_id}
        LIMIT 1;
    </select>

    <select id="getDodates" parameterType="String" resultType="String">
        SELECT DO_DATE
        FROM DODATES
        WHERE TASK_ID = #{task_id}
    </select>

    <select id="getMaxIdxOfNewDate" parameterType="map" resultType="String">
        SELECT COALESCE(MAX(D.TASK_ORDER) + 1, 0) AS new_idx
        FROM TASK T JOIN DODATES D
             ON T.TASK_ID = D.TASK_ID
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.DO_DATE = #{newDoDate}
        AND T.TASK_STATUS NOT IN (2,3);
    </select>

    <update id="orderMinus1BeforeDeletion" parameterType="taskhubdto">
        <!-- [case1: 이동하는 날짜그룹 상이] 1. taskid의 원래 do_date에서 현 task_id가 빠진 채로 다시 인덱싱하여 TASK_ORDER 부여 -->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET D.TASK_ORDER = D.TASK_ORDER - 1
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.DO_DATE = #{old_do_date}
        AND D.TASK_ORDER <![CDATA[>]]> #{old_order_idx};
    </update>

    <update id="r_orderMinus1BeforeDeletion" parameterType="taskhubdto">
        <!-- [case1: 이동하는 그룹 상이] -->
        UPDATE ROUTINE
        SET ROUTINE_ORDER = ROUTINE_ORDER - 1
        WHERE 1=1
        AND USER_ID = #{user_id}
        AND ROUTINE_GROUP = #{old_do_date}
        AND ROUTINE_ORDER <![CDATA[>]]> #{old_order_idx};
    </update>

    <update id="orderPlus1BeforeInsertion" parameterType="taskhubdto">
        <!-- [case1: 이동하는 날짜그룹 상이] 2. taskid가 이동하는 do_date에서 현 task_id가 이동하려는 인덱스 이하의 데이터들의 task_order 1 증가 -->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET D.TASK_ORDER = D.TASK_ORDER + 1
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.DO_DATE = #{new_do_date}
        AND D.TASK_ORDER >= #{new_order_idx};
    </update>

    <update id="r_orderPlus1BeforeInsertion" parameterType="taskhubdto">
        <!-- [case1: 이동하는 그룹 상이] -->
        UPDATE ROUTINE
        SET ROUTINE_ORDER = ROUTINE_ORDER + 1
        WHERE 1=1
        AND USER_ID = #{user_id}
        AND ROUTINE_GROUP = #{new_do_date}
        AND ROUTINE_ORDER >= #{new_order_idx};
    </update>

    <update id="updateOrderAndDoDateOfTask" parameterType="taskhubdto">
        <!-- [case1 & case2] 현재 taskid의 do_date와 task_order 변경-->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET
        <if test="task_done != null and task_done != ''">
            D.TASK_DONE = #{task_done},
        </if>
        D.DO_DATE = #{new_do_date},
        D.TASK_ORDER = #{new_order_idx}
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.TASK_ID = #{task_id}
        AND D.DO_DATE = #{old_do_date};
        <!--INSERT INTO DODATES (DO_DATE, TASK_ID, TASK_ORDER) VALUES
        (#{new_do_date},#{task_id},#{task_order_idx})-->
    </update>

    <update id="r_updateOrderAndDoDateOfTask" parameterType="taskhubdto">
        <!-- [case1 & case2] 현재 routineid의 do_date와 task_order 변경-->
        UPDATE ROUTINE
        SET
        ROUTINE_GROUP = #{new_do_date},
        ROUTINE_ORDER = #{new_order_idx}
        WHERE 1=1
        AND USER_ID = #{user_id}
        AND ROUTINE_ID = #{routine_id}
        AND ROUTINE_GROUP = #{old_do_date};
        <!--INSERT INTO DODATES (DO_DATE, TASK_ID, TASK_ORDER) VALUES
        (#{new_do_date},#{task_id},#{task_order_idx})-->
    </update>

    <update id="updateOrderAndDoDateInSameDateDown" parameterType="taskhubdto">
        <!-- [case2: 이동하는 날짜그룹 동일] 1. Moving Downwards -->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET D.TASK_ORDER = D.TASK_ORDER - 1
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.DO_DATE = #{new_do_date}
        AND D.TASK_ORDER > #{old_order_idx}
        <if test="new_order_idx != null">
        AND D.TASK_ORDER <![CDATA[<=]]> #{new_order_idx}
        </if>
    </update>

    <update id="r_updateOrderAndDoDateInSameDateDown" parameterType="taskhubdto">
        <!-- [case2: 이동하는 날짜그룹 동일] 1. Moving Downwards -->
        UPDATE ROUTINE
        SET ROUTINE_ORDER = ROUTINE_ORDER - 1
        WHERE 1=1
        AND USER_ID = #{user_id}
        AND ROUTINE_GROUP = #{new_do_date}
        AND ROUTINE_ORDER > #{old_order_idx}
        <if test="new_order_idx != null">
        AND ROUTINE_ORDER <![CDATA[<=]]> #{new_order_idx}
        </if>
    </update>

    <update id="updateOrderAndDoDateInSameDateUp" parameterType="taskhubdto">
        <!-- [case2: 이동하는 날짜그룹 동일] 2. Moving Upwards -->
        UPDATE DODATES D JOIN TASK T
               ON T.TASK_ID = D.TASK_ID
        SET D.TASK_ORDER = D.TASK_ORDER + 1
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.DO_DATE = #{new_do_date}
        AND D.TASK_ORDER >= #{new_order_idx}
        AND D.TASK_ORDER <![CDATA[<]]> #{old_order_idx};
    </update>

    <update id="r_updateOrderAndDoDateInSameDateUp" parameterType="taskhubdto">
        <!-- [case2: 이동하는 날짜그룹 동일] 2. Moving Upwards -->
        UPDATE ROUTINE
        SET ROUTINE_ORDER = ROUTINE_ORDER + 1
        WHERE 1=1
        AND USER_ID = #{user_id}
        AND ROUTINE_GROUP = #{new_do_date}
        AND ROUTINE_ORDER >= #{new_order_idx}
        AND ROUTINE_ORDER <![CDATA[<]]> #{old_order_idx};
    </update>

    <update id="assignTempOrderById" parameterType="String">
        -- 1. Temporarily set TASK_ORDER for the specified TASK_ID to a placeholder value
        UPDATE DODATES
        SET TASK_ORDER = 999999
        WHERE TASK_ID = #{task_id};
    </update>

    <update id="assignTempOrderByIdDate" parameterType="map">
        -- 1. Temporarily set TASK_ORDER for the specified TASK_ID to a placeholder value
        UPDATE DODATES
        SET TASK_ORDER = 999999
        WHERE TASK_ID = #{task_id}
          AND DO_DATE = #{do_date};
    </update>

    <update id="rearrangeOrderById" parameterType="map">
        -- Step 1: Define the CTE to calculate the new task order
        WITH OrderedTasks AS (
            SELECT
                D.DO_DATE,
                D.TASK_ID,
                CASE
                WHEN @current_do_date = D.DO_DATE THEN @row_number := @row_number + 1
                ELSE @row_number := 0
                END AS new_task_order,
                @current_do_date := D.DO_DATE
            FROM
            (SELECT @row_number := -1, @current_do_date := NULL) AS vars,  -- Initialize variables
            (SELECT D.* FROM DODATES D JOIN TASK T ON D.TASK_ID = T.TASK_ID
              WHERE 1=1
                <include refid="sessionUserId"/>
                AND D.DO_DATE IN (SELECT DO_DATE FROM DODATES WHERE TASK_ID = #{task_id})
                AND D.TASK_ID != #{task_id}
                AND D.TASK_ORDER IS NOT NULL
              ORDER BY D.DO_DATE, D.TASK_ORDER
            ) D
        )
        -- Step 2: Update the DODATES table with the new task order values
        UPDATE DODATES D JOIN OrderedTasks OT
               ON D.DO_DATE = OT.DO_DATE
        AND D.TASK_ID = OT.TASK_ID
        JOIN TASK T ON D.TASK_ID = T.TASK_ID  -- Join with TASK to filter by user_id
        SET D.TASK_ORDER = OT.new_task_order
        WHERE 1=1
        <include refid="sessionUserId"/>;  -- Ensure only rows for the specified user_id are updated

    </update>

    <update id="rearrangeOrderByIdDate" parameterType="map">
        -- Step 1: Define the CTE to calculate the new task order
        WITH OrderedTasks AS (
        SELECT
        D.DO_DATE,
        D.TASK_ID,
        CASE
        WHEN @current_do_date = D.DO_DATE THEN @row_number := @row_number + 1
        ELSE @row_number := 0
        END AS new_task_order,
        @current_do_date := D.DO_DATE
        FROM
        (SELECT @row_number := -1, @current_do_date := NULL) AS vars,  -- Initialize variables
        (SELECT D.*
        FROM DODATES D
        JOIN TASK T ON D.TASK_ID = T.TASK_ID
        WHERE 1=1
        <include refid="sessionUserId"/>
        AND D.DO_DATE = #{do_date}  -- Use the provided do_date parameter
        AND D.TASK_ID != #{task_id}  -- Exclude the specific task_id
        AND D.TASK_ORDER IS NOT NULL
        ORDER BY D.DO_DATE, D.TASK_ORDER
        ) D
        )
        -- Step 2: Update the DODATES table with the new task order values
        UPDATE DODATES D
        JOIN OrderedTasks OT ON D.DO_DATE = OT.DO_DATE
        AND D.TASK_ID = OT.TASK_ID
        JOIN TASK T ON D.TASK_ID = T.TASK_ID  -- Join with TASK to filter by user_id
        SET D.TASK_ORDER = OT.new_task_order
        WHERE 1=1
        AND D.DO_DATE = #{do_date}  -- Ensure only rows for the provided do_date are updated
        <include refid="sessionUserId"/>;  -- Ensure only rows for the specified user_id are updated

    </update>

    <update id="updateDetailDoDate" parameterType="map">
        UPDATE DODATES
           SET DO_DATE    = #{do_date},
               TASK_ORDER = #{task_order}
         WHERE TASK_ID    = #{task_id}
           AND DO_DATE    = #{old_date}
    </update>

    <delete id="deleteTask" parameterType="String">
        DELETE FROM TASK WHERE TASK_ID = #{task_id}
    </delete>

    <delete id="deleteWork" parameterType="map">
        DELETE FROM WORK WHERE WORK_ID = #{work_id} AND USER_ID = #{user_id}
    </delete>

    <delete id="deleteRoutine" parameterType="map">
        DELETE FROM ROUTINE WHERE ROUTINE_ID = #{routine_id} AND USER_ID = #{user_id}
    </delete>

    <update id="initializeRoutineOrderVariable">
        SET @newOrder := -1;
    </update>

    <update id="reorderRoutineOrderAfterDelete" parameterType="String">
        UPDATE ROUTINE
        SET ROUTINE_ORDER = (@newOrder := @newOrder + 1)
        WHERE ROUTINE_GROUP = #{routine_group}
        ORDER BY ROUTINE_ORDER ASC;
    </update>

    <delete id="deleteCategory" parameterType="map">
        DELETE FROM CATEGORY WHERE CATEGORY_ID = #{category_id} AND USER_ID = #{user_id}
    </delete>

    <select id="getCategories" resultType="taskhubdto">
        SELECT T.CATEGORY_ID, T.CATEGORY_NAME, T.CATEGORY_ORDER, T.USER_ID
        FROM CATEGORY T
        WHERE 1=1
        <include refid="sessionUserId"/>
        ORDER BY T.CATEGORY_ID;
    </select>

    <select id="findAllUsers" resultType="Long">
        SELECT userId
        FROM USER
    </select>

    <select id="findUncompletedUndone" parameterType="Long" resultType="taskhubdto">
        SELECT TASK_ID, DDATE AS DO_DATE
        FROM (
                SELECT
                MAX(D.do_date) AS DDATE,
                D.task_id AS TASK_ID,
                D.TASK_DONE AS TASK_DONE,
                D.TASK_ORDER AS TASK_ORDER
                FROM DODATES D
                WHERE D.TASK_ID IN (SELECT T.TASK_ID
                FROM TASK T
                WHERE 1=1
                <include refid="sessionUserId"/>
                AND T.TASK_STATUS NOT IN (2, 3)  -- 2: Completed, 3: Canceled
                )
        GROUP BY D.task_id
        ) AS LatestTask
        WHERE LatestTask.DDATE <![CDATA[<]]> CURDATE()
          AND (SELECT DD.TASK_DONE FROM DODATES DD
                WHERE DD.TASK_ID = LatestTask.TASK_ID
                  AND DD.DO_DATE = LatestTask.DDATE) != 2 -- 2: Done
        ORDER BY LatestTask.DDATE, LatestTask.TASK_ORDER
    </select>

    <select id="findUncompletedDone" parameterType="Long" resultType="String">
        SELECT TASK_ID
        FROM (
                SELECT
                MAX(D.do_date) AS DDATE,
                D.task_id AS TASK_ID,
                D.TASK_DONE AS TASK_DONE,
                D.TASK_ORDER AS TASK_ORDER
                FROM DODATES D
                WHERE D.TASK_ID IN (SELECT T.TASK_ID
                FROM TASK T
                WHERE 1=1
                <include refid="sessionUserId"/>
                AND T.TASK_STATUS NOT IN (2, 3)  -- 2: Completed, 3: Canceled
                )
        GROUP BY D.task_id
        ) AS LatestTask
        WHERE LatestTask.DDATE <![CDATA[<]]> CURDATE()
        AND (SELECT DD.TASK_DONE FROM DODATES DD
              WHERE DD.TASK_ID = LatestTask.TASK_ID
                AND DD.DO_DATE = LatestTask.DDATE) = 2 -- 2: Done
        ORDER BY LatestTask.DDATE, LatestTask.TASK_ORDER
        ;
    </select>

    <select id="isTaskExecutedToday" parameterType="String" resultType="boolean">
        SELECT COUNT(*)
        FROM task_execution_log
        WHERE 1=1 <!--user_id = #{userId}-->
        AND execution_date = #{today}
    </select>

    <insert id="saveExecutionLog" parameterType="map">
        INSERT INTO task_execution_log (execution_date)
        VALUES (#{today})
    </insert>

    <select id="isDuplicateOnSameDate" parameterType="map" resultType="int">
        SELECT COUNT(*)
        FROM DODATES
        WHERE 1=1
        AND TASK_ID = #{task_id}
        AND DO_DATE = #{do_date}
    </select>

    <select id="isOnlyDoDate" parameterType="String" resultType="int">
        SELECT COUNT(*)
        FROM DODATES
        WHERE 1=1
        AND TASK_ID = #{task_id}
    </select>

    <select id="isDone" parameterType="map" resultType="String">
        SELECT TASK_DONE
        FROM DODATES
        WHERE 1=1
        AND TASK_ID = #{task_id}
        AND DO_DATE = #{do_date}
    </select>

    <select id="isEveryTaskCompleted" parameterType="Long" resultType="int">
        SELECT COUNT(*)
        FROM TASK
        WHERE 1=1
        AND WORK_ID = #{work_id}
        AND TASK_STATUS != 2
    </select>

    <select id="isDuplicateUser" parameterType="String" resultType="int">
        SELECT COUNT(*)
        FROM USER
        WHERE 1=1
        AND userName = #{userName}
    </select>

    <select id="findSubTasks" parameterType="String" resultType="Long">
        SELECT TASK_ID
          FROM TASK
         WHERE PARENT_TASK = #{task_id}
    </select>

    <select id="findTasksUnderWork" parameterType="Long" resultType="Long">
        SELECT TASK_ID
        FROM TASK
        WHERE WORK_ID = #{work_id}
    </select>

    <select id="isRoutineInGroup" parameterType="Long" resultType="int">
        SELECT COUNT(*)
        FROM ROUTINE
        WHERE 1=1
        AND ROUTINE_GROUP = #{routine_id}
    </select>

    <select id="getRoutineCycleAndDay" parameterType="Long" resultType="map">
        SELECT REPETITION_CYCLE, REPETITION_DAY, ROUTINE_CONTENT, THIS_NEXT
        FROM ROUTINE
        WHERE 1=1
        AND ROUTINE_ID = #{routine_id}
    </select>

    <select id="getCategoryOfWork" parameterType="Long" resultType="String">
        SELECT CATEGORY_ID
        FROM WORK
        WHERE 1=1
        AND WORK_ID = #{work_id}
    </select>

</mapper>

